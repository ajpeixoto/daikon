// Copyright 2005 - 2024 Talend, Inc., All Rights Reserved - www.talend.com
package org.talend.daikon.avro;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.avro.Schema;
import org.apache.avro.Schema.Type;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;
import org.talend.daikon.exception.TalendRuntimeException;

/**
 * Provides methods and structures for generating and using simple generic records.
 */
public class GenericDataRecordHelper {

    private GenericDataRecordHelper() {
    }

    /**
     * Automatically creates a schema from the given object spec.
     *
     * If an object spec is simply a primitive (such as a Double), the Schema is also a primitive.
     *
     * If the object spec is an array, the Schema is an Record, where each field is named field0, field1, fieldN (and
     * the type of the field is recursively deduced from the corresponding value).
     *
     * If the object spec is an array of arrays, the Schema is an array of Records, where each field is named field0,
     * field1, fieldN (and the type of the field is recursively deduced from the corresponding value).
     *
     * Field names generated by this method are guaranteed to be unique.
     *
     * @param name a proposed record name, if this schema is a record type.
     * @param values the object values to base the schema on.
     * @param unions field names (not fully qualified) that should be assigned to union types (the actual type plus
     * null), or null if no fields should be unions.
     * @return a schema that corresponds to the values.
     */
    public static Schema createSchemaFromObject(String name, Object values, String... unions) {
        return createSchemaFromObject(name, unions.length == 0 ? null : new HashSet<>(Arrays.asList(unions)), values);
    }

    /**
     * Automatically creates a schema from the given object spec.
     *
     * If an object spec is simply a primitive (such as a Double), the Schema is also a primitive.
     *
     * If the object spec is an array, the Schema is an Record, where each field is named field0, field1, fieldN (and
     * the type of the field is recursively deduced from the corresponding value).
     *
     * If the object spec is an array of arrays, the Schema is an array of Records, where each field is named field0,
     * field1, fieldN (and the type of the field is recursively deduced from the corresponding value).
     *
     * Field names generated by this method are guaranteed to be unique.
     *
     * @param name a proposed record name, if this schema is a record type.
     * @param unions field names (not fully qualified) that should be assigned to union types (the actual type plus
     * null), or null if no fields should be unions.
     * @param values the object values to base the schema on.
     * @param internalNextRecordName if present, the character to use for the next record type encountered. This should
     * be ignored when this method is being called directly.
     * @return a schema that corresponds to the values.
     */
    public static Schema createSchemaFromObject(String name, Set<String> unions, Object values, char... internalNextRecordName) {

        // This is normally only set during a recursive call. If it wasn't set, use 'B' as the next record name.
        char[] nextRecordName = internalNextRecordName.length != 0 ? internalNextRecordName : new char[] { 'B' };

        Schema s;
        if (values instanceof Object[][]) {
            // Test for an array of objects first, otherwise it would *also* match the record condition.
            s = Schema.createArray(createSchemaFromObject(name, unions, ((Object[][]) values)[0], nextRecordName));
        } else if (values instanceof Object[]) {
            // If its an array, then create a record schema for it based on the elements of the array.
            // The base field name is the same as the name (in lower case), except if this is a direct call.
            String fieldName = internalNextRecordName.length != 0 ? name.toLowerCase() : "a";
            int fieldIndex = 1;

            ArrayList<Schema.Field> fields = new ArrayList<>();
            for (Object fieldSpec : (Object[]) values) {

                // If we know the nextRecordName will be used, then increment it pre-recursion.
                if (fieldSpec instanceof Object[]) {
                    String fieldRecordName = String.valueOf(nextRecordName[0]);
                    nextRecordName[0]++;
                    fields.add(new Schema.Field(fieldRecordName,
                            createSchemaFromObject(fieldRecordName, unions, fieldSpec, nextRecordName), null, null));
                } else {
                    fields.add(new Schema.Field(fieldName + fieldIndex,
                            createSchemaFromObject(fieldName + fieldIndex, unions, fieldSpec), null, null));
                    fieldIndex++;
                }
            }

            s = Schema.createRecord(name + "Record", null, null, false);
            s.setFields(fields);
        } else if (values instanceof Boolean) {
            // All other possible values are just primitive values.
            s = Schema.create(Type.BOOLEAN);
        } else if (values instanceof Long) {
            s = Schema.create(Type.LONG);
        } else if (values instanceof Integer) {
            s = Schema.create(Type.INT);
        } else if (values instanceof Double) {
            s = Schema.create(Type.DOUBLE);
        } else if (values instanceof Float) {
            s = Schema.create(Type.FLOAT);
        } else {
            // And anything else is considered to be a string.
            s = Schema.create(Type.STRING);
        }

        // Wrap it in a union if necessary.
        if (name != null && unions != null && unions.contains(name)) {
            s = Schema.createUnion(Arrays.asList(Schema.create(Type.NULL), s));
        }
        return s;
    }

    /**
     * Create both schema and record based on given input.
     *
     * @param values the values to assign to the fields of the record (in order).
     * @return an Avro data structure with a schema inferred from values and containing the specified values.
     */
    public static IndexedRecord createRecord(Object[] values) {
        final Schema schema = GenericDataRecordHelper.createSchemaFromObject("In", values);
        return GenericDataRecordHelper.createRecord(schema, values);
    }

    /**
     * Populates a record for the given schema, where the value for each field is taken in order from the specified
     * array of values.
     *
     * The specification for the values is the same as {@link #createSchemaFromObject}, so embedded records and arrays
     * are possible.
     *
     * @param recordSchema an Avro schema specifying a record.
     * @param values the values to assign to the fields of the record (in order).
     * @return an Avro data structure corresponding to the schema and containing the specified values.
     */
    public static IndexedRecord createRecord(Schema recordSchema, Object[] values) {
        IndexedRecord record = new GenericData.Record(recordSchema);
        int i = 0;
        for (Schema.Field f : recordSchema.getFields()) {

            // Get the schema for the field, finding the first non-null possible schema for unions.
            Schema fieldSchema = f.schema();
            if (fieldSchema.getType() == Type.UNION) {
                for (Schema possible : fieldSchema.getTypes()) {
                    if (possible.getType() != Type.NULL) {
                        fieldSchema = possible;
                        break;
                    }
                }
                if (fieldSchema.getType() == Type.UNION) {
                    throw TalendRuntimeException.createUnexpectedException("No non-null type found in union.");
                }
            }

            if (fieldSchema.getType() == Type.RECORD) {
                record.put(f.pos(), createRecord(fieldSchema, (Object[]) values[i++]));
            } else if (fieldSchema.getType() == Type.ARRAY) {
                record.put(f.pos(), createArray(fieldSchema, (Object[]) values[i++]));
            } else {
                record.put(f.pos(), values[i++]);
            }
        }
        return record;
    }

    /**
     * Populates an Avro array for the given schema, where the value for each element is from the specified array of
     * values.
     *
     * The specification for the values is the same as {@link #createSchemaFromObject}, so embedded records and arrays
     * are possible.
     *
     * @param arraySchema an Avro schema specifying a array.
     * @param values the values to assign to the elements of the Avro array (in order).
     * @return an Avro data structure corresponding to the schema and containing the specified values.
     */
    public static List<Object> createArray(Schema arraySchema, Object[] values) {
        if (values == null) {
            return null;
        }

        List<Object> array = new GenericData.Array<>(values.length, arraySchema);

        // Get the schema for the element type, finding the first non-null possible schema for unions.
        Schema elementSchema = arraySchema.getElementType();
        if (elementSchema.getType() == Type.UNION) {
            for (Schema possible : elementSchema.getTypes()) {
                if (possible.getType() != Type.NULL) {
                    elementSchema = possible;
                    break;
                }
            }
            if (elementSchema.getType() == Type.UNION) {
                throw TalendRuntimeException.createUnexpectedException("No non-null type found in union.");
            }
        }

        if (elementSchema.getType() == Type.RECORD) {
            for (Object v : values) {
                array.add(createRecord(elementSchema, (Object[]) v));
            }
        } else if (elementSchema.getType() == Type.ARRAY) {
            for (Object v : values) {
                array.add(createArray(elementSchema, (Object[]) v));
            }
        } else {
            for (Object v : values) {
                array.add(v);
            }
        }
        return array;
    }
}
