// Copyright 2005 - 2024 Talend, Inc., All Rights Reserved - www.talend.com
package org.talend.daikon.pattern.word;

import static org.talend.daikon.pattern.PatternRegexUtils.escapeCharacters;

import java.util.ArrayList;
import java.util.List;

/**
 * This class can convert word pattern generated by DQ lib (in statistics package) to a regex.
 */
public class WordPatternToRegex {

    private WordPatternToRegex() {
        // Do not instantiate
    }

    public static String toRegex(String pattern, boolean caseSensitive) {
        StringBuilder sb = new StringBuilder();
        sb.append("^");
        for (String current : splitPattern(pattern)) {
            WordPattern wordPattern = WordPattern.get(current);
            String regex;
            if (wordPattern == null)
                regex = escapeCharacters(current);
            else if (caseSensitive)
                regex = wordPattern.getCaseSensitive();
            else
                regex = wordPattern.getCaseInsensitive();
            sb.append(regex);
        }
        sb.append("$");
        return sb.toString();

    }

    private static List<String> splitPattern(final String pattern) {
        List result = new ArrayList<String>();
        if (pattern.startsWith("[")) {
            int closeBracket = pattern.indexOf(']');
            int openBracket = pattern.indexOf('[', 1);
            if (closeBracket > 0 && (closeBracket < openBracket || openBracket == -1)) {
                String extracted = pattern.substring(0, closeBracket + 1);
                result.add(extracted);
                if (closeBracket + 1 < pattern.length()) {
                    result.addAll(splitPattern(pattern.substring(closeBracket + 1)));
                }
            } else if (closeBracket == -1) { // No more close bracket
                result.add(pattern);
            } else { // closeBracket > openBracket and there exist a second open bracket
                result.add(pattern.substring(0, openBracket));
                result.addAll(splitPattern(pattern.substring(openBracket)));
            }
        } else {
            int openBracket = pattern.indexOf('[', 1);
            if (openBracket == -1)
                result.add(pattern);
            else {
                result.add(pattern.substring(0, openBracket));
                result.addAll(splitPattern(pattern.substring(openBracket)));
            }

        }
        return result;
    }

}
